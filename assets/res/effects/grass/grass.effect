// Effect Syntax Guide: https://github.com/cocos-creator/docs-3d/blob/master/zh/material-system/effect-syntax.md

CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: vs:vert
      frag: fs:frag
      properties: &props
        alphaTest:      { value: 0.5 }

        windMap:        { value: white }
        windDirection: { value: [1, 1] }
        windSpeed: { value: 4 }
        windStrength: { value: 0.2 }
        windSwinging: { value: 0.17 }
        windRandObject: { value: 1 }
        windRandVertex: { value: 1 }
        windRandObjectStrength: { value: 0.709 }
        windGustStrength: { value: 0.196 }
        windGustFrequency: { value: 2.27 }
        windGustTint: { value: 2.27 }

        mainTexture:    { value: white }
        mainColor:      { value: [1, 1, 1, 1], editor: { type: color } }
        hueColor:       { value: [1, 1, 1, 1], editor: { type: color } }
        ambientOcclusion: { value: 0.704 }
        randomDarken: { value: 0.287 }

        specularHighlight: { value: 0 }
        translucency: { value: 1 }
    - vert: shadow-caster-vs:vert
      frag: shadow-caster-fs:frag
      phase: shadow-add
      propertyIndex: 0
      rasterizerState:
        cullMode: back
  - name: transparent
    passes:
    - vert: vs:vert
      frag: fs:frag
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendSrcAlpha: src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
    - vert: shadow-caster-vs:vert
      frag: shadow-caster-fs:frag
      phase: shadow-add
      propertyIndex: 0
      rasterizerState:
        cullMode: back
}%

CCProgram shared-funcs %{
  #include <cc-global>
  
  #include <./wind>
  #include <./bend>
  
  WindSettings getWinSettings (float mask) {
    WindSettings s;

    s.ambientStrength = windStrength;
    s.speed = windSpeed;
    s.direction = windDirection;
    s.swinging = windSwinging;
    s.mask = mask;
    s.randObject = windRandObject;
    s.randVertex = windRandVertex;
    s.randObjectStrength = windRandObjectStrength;
    s.gustStrength = windGustStrength;
    s.gustFrequency = windGustFrequency;

    return s;
  }

  BendSettings getBendSettings (float mask) {
    BendSettings s;
    s.mode = 0;
    s.mask = mask;
    s.pushStrength = 1.;
	  s.flattenStrength = 1.;
	  s.perspectiveCorrection = 1.;
    return s;
  }

  float randomRange (vec2 seed, float minv, float maxv) {
    float randomno = fract(sin(dot(seed, vec2(12.9898, 78.233)))*43758.5453);
    return mix(minv, maxv, randomno);
  }

  float objectPosRand01(mat4 mat) {
    return fract(mat[3][0] + mat[3][1] + mat[3][2]);
  }

  void calcGrassOffset (in vec4 lPos, inout vec4 wPos, float rand, vec3 colorAttr) {
    float mask = colorAttr.r;

    WindSettings w = getWinSettings(mask);
    vec4 windOffset = getWindOffset(lPos.xyz, wPos.xyz, rand, w, windMap);

    BendSettings b = getBendSettings(mask);
    vec4 bendOffset = getBendOffset(wPos.xyz, b);

    vec3 offsets = mix(windOffset.xyz, bendOffset.xyz, bendOffset.a).xyz;

    vec3 viewDirectionWS = normalize(cc_cameraPos.xyz - wPos.xyz);
    float NdotV = dot(vec3(0, 1, 0), viewDirectionWS);

    //Avoid pushing grass straight underneath the camera in a falloff of 4 units (1/0.25)
    float dist = clamp(distance(wPos.xz, cc_cameraPos.xz) * 0.25, 0., 1.);

    //Push grass away from camera position
    vec2 pushVec = -viewDirectionWS.xz;
    float perspMask = b.mask * b.perspectiveCorrection * dist * NdotV;
    offsets.xz += pushVec.xy * perspMask;
  
    //Apply bend offset
    wPos.xz += offsets.xz;
    wPos.y -= offsets.y;
  }

  vec4 calcGrassVertexColor(in vec4 lPos, in vec4 wPos, float rand, vec3 colorAttr) {
    return applyVertexColor(lPos.xyz, wPos.xyz, mainColor.xyz, colorAttr.r, ambientOcclusion, randomDarken, hueColor, rand);
  }
}%

CCProgram shared-ubos %{
  
  uniform sampler2D windMap;
  uniform Wind {
    vec2 windDirection;
    float windStrength;
    float windSpeed;
    float windSwinging;
    float windRandObject;
    float windRandVertex;
    float windRandObjectStrength;
    float windGustStrength;
    float windGustFrequency;
    float windGustTint;
  };


  uniform sampler2D mainTexture;
  uniform Color {
    vec4 mainColor;
    vec4 hueColor;
    float ambientOcclusion;
    float randomDarken;

    float specularHighlight;
    float translucency;

    float alphaTest;
  };

}%

CCProgram vs %{
  precision highp float;
  #include <input-standard>
  #include <cc-global>
  #include <cc-local-batch>
  #include <input-standard>
  #include <cc-fog>
  #include <cc-shadow-map-vs>

  #include <./color>
  #include <shared-ubos>
  #include <shared-funcs>

  in vec3 a_color;
  #if HAS_SECOND_UV
    in vec2 a_texCoord1;
  #endif

  out vec3 v_wPos;
  out vec3 v_normal;
  out vec3 v_tangent;
  out vec3 v_bitangent;
  out vec2 v_uv;
  out vec2 v_uv1;
  out vec4 v_color;
  out float factor_fog;

  vec4 vert () {
    StandardVertInput In;
    CCVertInput(In);

    mat4 matWorld, matWorldIT;
    CCGetWorldMatrixFull(matWorld, matWorldIT);

    vec4 lPos = In.position;
    vec4 wPos = matWorld * lPos;

    float rand = objectPosRand01(matWorld); // should be 0 - 1;
    calcGrassOffset(lPos, wPos, rand, a_color);

    v_color = calcGrassVertexColor(lPos, wPos, rand, a_color);

    v_wPos = wPos.xyz;
    v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);
    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);
    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w; // note the cross order

    v_uv = a_texCoord;
    #if HAS_SECOND_UV
      v_uv1 = a_texCoord1;
    #endif
    factor_fog = CC_TRANSFER_FOG(wPos);

    CCPassShadowParams(wPos);

    return cc_matProj * cc_matView * wPos;
  }

}%

CCProgram fs %{
  precision highp float;
  #include <output>
  #include <cc-fog>
  #include <gamma>

  #include <./color>
  #include <shared-ubos>
  #include <shared-funcs>

  in vec2 v_uv;
  in vec4 v_color;
  in float factor_fog;

  in vec3 v_wPos;

  vec3 Translucency(vec3 viewDirectionWS, float amount) {
    vec3 ld = normalize(cc_mainLitDir.xyz);
    float VdotL = max(0., dot(viewDirectionWS, ld)) * amount;

    //TODO: Incorperate size parameter
    VdotL = pow(VdotL, 4.) * 8.;

    //Translucency masked by shadows and grass mesh bottom
    float tMask = VdotL;// * light.shadowAttenuation * light.distanceAttenuation;

    //Fade the effect out as the sun approaches the horizon (75 to 90 degrees)
    // float sunAngle = dot(vec3(0., 1., 0.), ld);
    // float angleMask = clamp(sunAngle * 6.666, 0., 1.); /* 1.0/0.15 = 6.666 */

    // tMask *= angleMask;

    return clamp(tMask * cc_mainLitColor.rgb * cc_mainLitColor.w, 0., 1.);
  }

  vec4 frag () {
    vec4 col = texture(mainTexture, v_uv);
    // col.rgb = SRGBToLinear(col.rgb);

    float alpha = col.a;
    vec3 albedo = col.rgb;

    if (alpha < alphaTest) {
      discard;
    }

    // apply vertex color
    albedo *= v_color.rgb;

    // wind gust color
	  WindSettings wind = getWinSettings(v_color.r);
    wind.gustStrength = 1.;
    float gust = sampleGustMap(v_wPos, wind, windMap);
	  albedo += min(vec3(gust * 10. * v_color.a), windGustTint);

    // translucency
    vec3 viewDirection = normalize(cc_cameraPos.xyz - v_wPos);
    vec3 transmissionColor = Translucency(viewDirection, translucency);

	  albedo += BlendOverlay(transmissionColor * 2.0, albedo);

    vec4 final = vec4(albedo, alpha);
    final = CC_APPLY_FOG(final, factor_fog);

    return final;
  }
}%

CCProgram shadow-caster-vs %{
  precision highp float;
  #include <input-standard>
  #include <cc-local-batch>
  #include <cc-shadow>

  #include <shared-ubos>
  #include <shared-funcs>

  out vec2 v_uv;

  out vec2 v_clip_depth;

  in vec3 a_color;

  vec4 vert () {
    StandardVertInput In;
    CCVertInput(In);

    mat4 matWorld, matWorldIT;
    CCGetWorldMatrixFull(matWorld, matWorldIT);

    vec4 lPos = In.position;
    vec4 wPos = matWorld * lPos;

    float rand = objectPosRand01(matWorld); // should be 0 - 1;
    calcGrassOffset(lPos, wPos, rand, a_color);


    vec4 clipPos = cc_matLightViewProj * wPos;

    v_uv = a_texCoord;

    v_clip_depth = clipPos.zw;

    return clipPos;
  }
}%

CCProgram shadow-caster-fs %{
  precision highp float;
  #include <packing>

  #include <shared-ubos>

  in vec2 v_uv;
  in vec2 v_clip_depth;


  vec4 frag () {
    vec4 baseColor = texture(mainTexture, v_uv);
    if (baseColor.a < alphaTest) discard;

    return packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);
  }
}%
