uniform Color {
    vec4 hueColor;
    float ambientOcclusion;
    float randomDarken;

    float specularHighlight;
    float translucency;
};

//Single channel overlay
float BlendOverlay(float a, float b)
{
	return (b < 0.5) ? 2.0 * a * b : 1.0 - 2.0 * (1.0 - a) * (1.0 - b);
}

//RGB overlay
vec3 BlendOverlay(vec3 a, vec3 b)
{
	vec3 color;
	color.r = BlendOverlay(a.r, b.r);
	color.g = BlendOverlay(a.g, b.g);
	color.b = BlendOverlay(a.b, b.b);
	return color;
}


//Shading (RGB=hue - A=brightness)
vec4 applyVertexColor(in vec3 vertexPos, in vec3 wPos, in vec3 baseColor, in float mask, in float aoAmount, in float darkening, in vec4 hue, in float posOffset)
{
	vec4 col = vec4(baseColor, 1.);

	//Apply hue
	col.rgb = mix(col.rgb, hue.rgb, posOffset * hue.a);
	//Apply darkening
	float rand = fract(vertexPos.r * 4.);

	float vertexDarkening = mix(col.a, col.a * rand, darkening * mask); //Only apply to top vertices
	//Apply ambient occlusion
	float ambientOcclusion = mix(col.a, col.a * mask, aoAmount);

	col.rgb *= vertexDarkening * ambientOcclusion;

	//Pass vertex color alpha-channel to fragment stage. Used in some shading functions such as translucency
	col.a = mask;

	return col;
}